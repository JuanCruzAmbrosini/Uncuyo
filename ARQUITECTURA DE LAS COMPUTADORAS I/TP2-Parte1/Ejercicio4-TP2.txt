;Escribir un programa que sume dos números de 16 bits.
;● Almacene los 8 bits de menor peso del primer operando en la ;posición de memoria
;0x52 y los 8 bits de mayor peso en la posición de memoria 0x51.
;● Almacene los 8 bits de menor peso del segundo operando en la ;posición de
;memoria 0x62 y los 8 bits de mayor peso en la posición de memoria ;0x61.
;● El resultado deberá quedar en las posiciones 0x72 (los 8 bits de ;menor peso), 0x71
;(8 bits de mayor peso) y en la 0x70 el acarreo final.
;Tenga en cuenta que el procesador del simulador solo puede sumar ;números de 8 bits.
;Sugerencia: Recuerde el ejercicio de unir dos sumadores de 4 bits ;para formar un sumador
;de 8 bits del trabajo práctico Nº1. El razonamiento será el mismo. ;Analice el uso de las
;instrucciones jc (saltar si hay acarreo) y jnc (saltar si no hay ;}
;acarreo).

;El programa se puede adaptar al caso de que el valor en el espacio 
;de memoria ubicado en 0x51 valga 0xFF, pero tendría que mover el 
;lugar donde estan alojadas las variables.

	jmp start

start: 
	mov [0x52], 0x97
	mov [0x51], 0x83

	mov [0x62], 0xF2
	mov [0x61], 0x83

sum:
	mov A, [0x52]
	mov B, [0x62]
	call sumLessSign
	mov A, [0x51]
	mov B, [0x61]
	call sumMoreSign
	call end

sumLessSign:
	add A,B
	jc .writeCarryLs
	jnc .writeNotCarryLs
.writeCarryLs:
	mov [0x72], A
	mov C, 0x01
	ret
.writeNotCarryLs:
	mov [0x72], A
	ret
	
sumMoreSign:
	add A,C
	add A,B
	jc .writeCarryMs
	jnc .writeNotCarryMs
.writeCarryMs:
	mov C, 0x01
	mov [0x71], A
	mov [0x70], C
	ret
.writeNotCarryMs:
	mov C, 0x00
	mov [0x71], A
	mov C, [0x70]
	ret

end: hlt





